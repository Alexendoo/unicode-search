use anyhow::Result;
use indoc::writedoc;
use proc_macro2::Literal;
use std::env;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::PathBuf;
use ucd_parse::{NameAlias, UcdFile, UnicodeData};

fn relative_path(p: &str) -> PathBuf {
    let mut path = PathBuf::new();
    path.push(env!("CARGO_MANIFEST_DIR"));
    path.push(p);
    path
}

fn out_file(filename: &str) -> Result<BufWriter<File>> {
    let mut path = relative_path("../shared/src/");
    path.push(filename);

    let file = File::create(path)?;

    Ok(BufWriter::new(file))
}

fn parse<D: UcdFile>() -> Result<Vec<D>, ucd_parse::Error> {
    let path = relative_path("ucd-data");
    ucd_parse::parse(path)
}

fn write_bytes(filename: &str, xs: &[usize]) -> Result<()> {
    let mut file = out_file(filename)?;

    for x in xs {
        file.write_all(&x.to_le_bytes())?;
    }

    Ok(())
}

fn main() -> Result<()> {
    let unicode_data = parse::<UnicodeData>()?;
    let name_aliases = parse::<NameAlias>()?;

    let mut names = Vec::new();

    for row in &unicode_data {
        if row.is_range_start() || row.is_range_end() || row.name == "<control>" {
            continue;
        }

        names.push((row.name.as_str(), row.codepoint.scalar().unwrap()));
    }

    for row in &name_aliases {
        names.push((row.alias.as_str(), row.codepoint.scalar().unwrap()));
    }

    // stable sort to keep canonical names first
    names.sort_by_key(|&(_, literal)| literal);

    // TODO: include multiple aliases
    names.dedup_by_key(|&mut (_, literal)| literal);

    let mut indices = Vec::new();
    let mut all_names = String::new();
    let mut characters = String::new();

    for (i, &(name, ch)) in names.iter().enumerate() {
        let pos = all_names.len() | (name.len() << 24);

        characters.push_str(&format!(
            "    Character {{ pos: {}, literal: {} }},\n",
            pos,
            Literal::character(ch),
        ));

        all_names.push_str(name);
        all_names.push('\n');

        for _ in 0..=name.len() {
            indices.push(i);
        }
    }

    let mut suffix_table: Vec<usize> = (0..all_names.len()).collect();
    suffix_table.sort_unstable_by_key(|&i| &all_names[i..]);

    assert_eq!(indices.len(), all_names.len());
    assert_eq!(all_names.len(), suffix_table.len());
    assert!(suffix_table.len() < u32::MAX as usize);

    writedoc!(
        out_file("characters.rs")?,
        "
            // File generated by gen/src/main.rs

            use std::str;
            use crate::NAMES;

            #[derive(Copy, Clone)]
            pub struct Character {{
                pos: u32,
                pub literal: char,
            }}

            impl Character {{
                pub fn name(self) -> &'static str {{
                    let start = self.pos & 0xFF_FF_FF;
                    let end = start + (self.pos << 24);

                    unsafe {{
                        NAMES.get_unchecked(start as usize..end as usize)
                    }}
                }}
            }}

            pub type Characters = &'static [Character];
            pub const CHARACTERS: Characters = &[
            {}];
        ",
        characters,
    )?;

    write!(out_file("names.txt")?, "{}", all_names)?;

    write_bytes("suffix_table.u32", &suffix_table)?;
    write_bytes("indices.u32", &indices)?;

    Ok(())
}
