use anyhow::{ensure, Result};
use proc_macro2::TokenStream;
use quote::quote;
use std::io::Write;
use std::{env, fs::File};
use std::{fs::create_dir_all, path::PathBuf};
use std::{io::BufWriter, process::Command};
use ucd_parse::{NameAlias, UcdFile, UnicodeData};

fn relative_path(p: &str) -> PathBuf {
    let mut path = PathBuf::new();
    path.push(env!("CARGO_MANIFEST_DIR"));
    path.push(p);
    path
}

fn out_file(path: &PathBuf) -> Result<BufWriter<File>> {
    create_dir_all(path.parent().unwrap())?;

    let file = File::create(path)?;

    Ok(BufWriter::new(file))
}

fn rustfmt(file: &PathBuf) -> Result<()> {
    match Command::new("rustfmt").arg("--").arg(file).status() {
        Ok(status) => ensure!(status.success(), "rustfmt exit status: {:?}", status),
        _ => eprintln!("warning: rustfmt not found"),
    }

    Ok(())
}

fn parse<D: UcdFile>() -> Result<Vec<D>, ucd_parse::Error> {
    let path = relative_path("ucd-data");
    ucd_parse::parse(path)
}

fn main() -> Result<()> {
    let unicode_data = parse::<UnicodeData>()?;
    let name_aliases = parse::<NameAlias>()?;

    let mut names = Vec::new();

    for row in &unicode_data {
        if row.is_range_start() || row.is_range_end() || row.name == "<control>" {
            continue;
        }

        names.push((row.name.as_str(), row.codepoint.value()));
    }

    for row in &name_aliases {
        names.push((row.alias.as_str(), row.codepoint.value()));
    }

    // stable sort to keep canonical names first
    names.sort_by_key(|&(_, codepoint)| codepoint);

    names.truncate(50);

    let characters: TokenStream = names
        .iter()
        .map(|&(name, codepoint)| quote!( Character { name: #name, codepoint: #codepoint }, ))
        .collect();

    let out = quote! {
        use std::convert::TryInto;

        #[derive(Copy, Clone)]
        pub struct Character {
            pub name: &'static str,
            pub codepoint: u32,
        }

        impl Character {
            pub fn literal(&self) -> char {
                self.codepoint.try_into().unwrap()
            }
        }

        pub type Characters = &'static [Character];
        pub const CHARACTERS: Characters = &[#characters];
    };

    let names_filename = relative_path("../shared/src/characters.rs");
    let mut names_file = out_file(&names_filename)?;

    write!(
        names_file,
        "// File generated by gen/src/main.rs\n\n{}",
        out
    )?;
    names_file.flush()?;

    rustfmt(&names_filename)?;

    Ok(())
}
