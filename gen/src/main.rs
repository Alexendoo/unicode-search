use anyhow::Result;
use indoc::writedoc;
use proc_macro2::Literal;
use std::env;
use std::fmt::Display;
use std::fs::create_dir_all;
use std::fs::File;
use std::io::BufWriter;
use std::io::Write;
use std::path::PathBuf;
use ucd_parse::{NameAlias, UcdFile, UnicodeData};

fn relative_path(p: &str) -> PathBuf {
    let mut path = PathBuf::new();
    path.push(env!("CARGO_MANIFEST_DIR"));
    path.push(p);
    path
}

fn out_file(path: &PathBuf) -> Result<BufWriter<File>> {
    create_dir_all(path.parent().unwrap())?;

    let file = File::create(path)?;

    Ok(BufWriter::new(file))
}

fn parse<D: UcdFile>() -> Result<Vec<D>, ucd_parse::Error> {
    let path = relative_path("ucd-data");
    ucd_parse::parse(path)
}

fn format_table<T: Display>(table: &[T]) -> String {
    let mut out = "   ".to_string();
    let mut count = out.len();

    for e in table {
        let s = e.to_string();

        count += s.len() + 2;

        if count > 200 {
            out.push_str("\n    ");
            out.push_str(&s);
            out.push(',');

            count = 5 + s.len();
        } else {
            out.push(' ');
            out.push_str(&s);
            out.push(',');
        }
    }

    out
}

fn main() -> Result<()> {
    let unicode_data = parse::<UnicodeData>()?;
    let name_aliases = parse::<NameAlias>()?;

    let mut names = Vec::new();

    for row in &unicode_data {
        if row.is_range_start() || row.is_range_end() || row.name == "<control>" {
            continue;
        }

        names.push((row.name.as_str(), row.codepoint.scalar().unwrap()));
    }

    for row in &name_aliases {
        names.push((row.alias.as_str(), row.codepoint.scalar().unwrap()));
    }

    // stable sort to keep canonical names first
    names.sort_by_key(|&(_, literal)| literal);

    // TODO: include multiple aliases
    names.dedup_by_key(|&mut (_, literal)| literal);

    let mut indices = Vec::new();
    let mut all_names = String::new();
    let mut characters = String::new();

    for (i, &(name, ch)) in names.iter().enumerate() {
        characters.push_str(&format!(
            "    Character {{ name: name({}, {}), literal: {} }},\n",
            all_names.len(),
            name.len(),
            Literal::character(ch),
        ));

        all_names.push_str(name);
        all_names.push('\n');

        for _ in 0..=name.len() {
            indices.push(i);
        }
    }

    let mut suffix_table: Vec<usize> = (0..all_names.len()).collect();
    suffix_table.sort_unstable_by_key(|&i| &all_names[i..]);

    assert_eq!(indices.len(), all_names.len());
    assert_eq!(all_names.len(), suffix_table.len());
    assert!(suffix_table.len() < u32::MAX as usize);

    let names_filename = relative_path("../shared/src/characters.rs");
    let mut names_file = out_file(&names_filename)?;

    writedoc!(
        names_file,
        "
            // File generated by gen/src/main.rs

            #[derive(Copy, Clone)]
            pub struct Character {{
                pub name: &'static str,
                pub literal: char,
            }}

            pub const NAMES: &'static str = \"{}\";

            pub type Characters = &'static [Character];
            pub const CHARACTERS: Characters = &[
            {}
            ];

            pub const SUFFIX_TABLE: &'static [u32] = &[
            {}
            ];

            pub const INDICES: &'static [u32] = &[
            {}
            ];
        ",
        all_names,
        characters,
        format_table(&suffix_table),
        format_table(&indices),
    )?;
    names_file.flush()?;

    Ok(())
}
